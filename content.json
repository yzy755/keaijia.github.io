[{"title":"基于shiro拓展并发登录人数控制","date":"2017-04-11T09:17:53.000Z","path":"2017/04/11/基于shiro拓展并发登录人数控制/","text":"在公司做了个视频网站，当然视频是需要购买的，就像爱奇艺那样，所以同一用户就要有一个客户端登录个数的控制，不然一个用户买了，能让一个公司的人看- -！spring security就直接提供了相应的功能；我的项目使用的权限框架是apach的shiro，Shiro的话没有提供默认实现，不过可以很容易的在Shiro中加入这个功能我们来看下shiro拦截机制中filter的关系图这里只介绍AccessControlFilter： AccessControlFilter提供了访问控制的基础功能；比如是否允许访问/当访问拒绝时如何处理等： abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception; boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception; abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception; isAccessAllowed：表示是否允许访问；mappedValue就是[urls]配置中拦截器参数部分，如果允许访问返回true，否则false； onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回true表示需要继续处理；如果返回false表示该拦截器实例已经处理了，将直接返回即可。 onPreHandle会自动调用这两个方法决定是否继续处理： boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue); } 另外AccessControlFilter还提供了如下方法用于处理如登录成功后/重定向到上一个请求： void setLoginUrl(String loginUrl) //身份验证时使用，默认/login.jsp String getLoginUrl() Subject getSubject(ServletRequest request, ServletResponse response) //获取Subject实例 boolean isLoginRequest(ServletRequest request, ServletResponse response)//当前请求是否是登录请求 void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException //将当前请求保存起来并重定向到登录页面 void saveRequest(ServletRequest request) //将请求保存起来，如登录成功后再重定向回该请求 void redirectToLogin(ServletRequest request, ServletResponse response) //重定向到登录页面 比如基于表单的身份验证就需要使用这些功能。 如果我们想进行访问访问的控制就可以继承AccessControlFilter；如果我们要添加一些通用数据我们可以直接继承PathMatchingFilter。所以定义一个类继承AccessControlFilter重写onAccessDenied方法，isAccessAllowed方法直接返回false，使程序进入拒绝访问的处理过程，也就是onAccessDenied方法，在这个方法中，我们的思路就是 1.使用链表记录同一用户的登录sessionid，用shiro提供的cache记录用户和session的映射关系，用户名为key,链表为value 2.用户登录后使用subject拿到用户名，以用户名取出当前服务器存储的sessionid链表，判断链表中有无当前登录的sessionid，无则push 3.判断链表的的长度，若大于系统允许的登录数，链表进行移除操作，获得移除的session并标记为被踢出（移除的顺序可配置为踢前者或者后者） 4.被移除的session（客户端）再次访问系统页面时，走完上述过程发现自己有被踢出的标记，调用subject.logout()方法，并重定向到踢出的提示页面帖一波代码： public class KickoutSessionControlFilter extends AccessControlFilter { private Logger logger = LoggerFactory.getLogger(KickoutSessionControlFilter.class); private String kickoutUrl; // 踢出后到的地址 private boolean kickoutAfter; // 踢出之前登录的或之后登录的用户 (在配置文件中配) private int maxSession = 1; // 同一个帐号最大会话数 默认1 private SessionManager sessionManager; private Cache&lt;String, Deque&lt;Serializable&gt;&gt; cache; @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { return false; } @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception { Subject subject = getSubject(request, response); if (!subject.isAuthenticated() &amp;&amp; !subject.isRemembered()) { // 如果没有登录，直接进行之后的流程 return true; } Session session = subject.getSession(); String username = (String) subject.getPrincipal(); Serializable sessionId = session.getId(); // 同步控制 Deque&lt;Serializable&gt; deque = cache.get(username); if (deque == null) { deque = new LinkedList&lt;Serializable&gt;(); } // 如果队列里没有此sessionId，且用户没有被踢出；放入队列 if (!deque.contains(sessionId) &amp;&amp; session.getAttribute(&quot;kickout&quot;) == null) { deque.push(sessionId); } // 如果队列里的sessionId数超出最大会话数，开始踢人 while (deque.size() &gt; maxSession) { Serializable kickoutSessionId = null; if (kickoutAfter) { // 如果踢出后者 kickoutSessionId = deque.removeFirst(); } else { // 否则踢出前者 kickoutSessionId = deque.removeLast(); } try { Session kickoutSession = sessionManager.getSession(new DefaultSessionKey(kickoutSessionId)); if (kickoutSession != null) { // 设置会话的kickout属性表示踢出了 kickoutSession.setAttribute(&quot;kickout&quot;, true); } } catch (Exception e) { e.printStackTrace(); logger.error(e.getMessage(), e); } } cache.put(username, deque); // 如果被踢出了，直接退出，重定向到踢出后的地址 if (session.getAttribute(&quot;kickout&quot;) != null) { try { subject.logout(); } catch (Exception e) { e.printStackTrace(); logger.error(e.getMessage(), e); } saveRequest(request); WebUtils.issueRedirect(request, response, kickoutUrl); return false; } return true; } public void setKickoutUrl(String kickoutUrl) { this.kickoutUrl = kickoutUrl; } public void setKickoutAfter(boolean kickoutAfter) { this.kickoutAfter = kickoutAfter; } public void setMaxSession(int maxSession) { this.maxSession = maxSession; } public void setSessionManager(SessionManager sessionManager) { this.sessionManager = sessionManager; } public void setCacheManager(CacheManager cacheManager) { this.cache = cacheManager.getCache(&quot;shiro-kickout-session&quot;); } } 当然上述的实现离不开shiro的正确配置，帖一波配置： &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realms&quot;&gt; &lt;util:list id=&quot;beanList&quot;&gt; &lt;ref bean=&quot;myCasRealm&quot; /&gt; &lt;ref bean=&quot;myLoginRealm&quot; /&gt; &lt;/util:list&gt; &lt;/property&gt; &lt;!-- &lt;property name=&quot;realm&quot; ref=&quot;myCasRealm&quot; /&gt; --&gt; &lt;property name=&quot;subjectFactory&quot; ref=&quot;casSubjectFactory&quot; /&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot; /&gt; &lt;/bean&gt; &lt;!-- 如果要实现cas的remember me的功能，需要用到下面这个bean，并设置到securityManager的subjectFactory中 --&gt; &lt;bean id=&quot;casSubjectFactory&quot; class=&quot;org.apache.shiro.cas.CasSubjectFactory&quot; /&gt; &lt;!-- 項目自定义的Realm --&gt; &lt;bean id=&quot;myCasRealm&quot; class=&quot;com.booway.shiro.MyCasRealm&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt; &lt;property name=&quot;casServerUrlPrefix&quot; value=&quot;${cas.server.url}&quot; /&gt; &lt;!-- 客户端的回调地址设置，必须和下面的shiro-cas过滤器拦截的地址一致 --&gt; &lt;property name=&quot;casService&quot; value=&quot;/cas&quot; /&gt; &lt;/bean&gt; &lt;!-- 項目自定义的Realm --&gt; &lt;bean id=&quot;myLoginRealm&quot; class=&quot;com.booway.shiro.MyLoginRealm&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt; &lt;property name=&quot;casServerUrlPrefix&quot; value=&quot;${cas.server.url}&quot; /&gt; &lt;!-- 客户端的回调地址设置，必须和下面的shiro-cas过滤器拦截的地址一致 --&gt; &lt;property name=&quot;casService&quot; value=&quot;/cas&quot; /&gt; &lt;/bean&gt; &lt;!-- 用户授权信息Cache --&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.MemoryConstrainedCacheManager&quot; /&gt; &lt;!-- 会话ID生成器 --&gt; &lt;bean id=&quot;sessionIdGenerator&quot; class=&quot;org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator&quot;/&gt; &lt;!-- 会话DAO --&gt; &lt;bean id=&quot;sessionDAO&quot; class=&quot;org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&quot;&gt; &lt;property name=&quot;activeSessionsCacheName&quot; value=&quot;shiro-activeSessionCache&quot;/&gt; &lt;property name=&quot;sessionIdGenerator&quot; ref=&quot;sessionIdGenerator&quot;/&gt; &lt;/bean&gt; &lt;!-- 会话Cookie模板 --&gt; &lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;constructor-arg value=&quot;sid&quot;/&gt; &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;maxAge&quot; value=&quot;3600&quot;/&gt; &lt;/bean&gt; &lt;!-- 会话管理器 --&gt; &lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt; &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1800000&quot;/&gt; &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;sessionValidationScheduler&quot; ref=&quot;sessionValidationScheduler&quot;/&gt; &lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot;/&gt; &lt;property name=&quot;sessionIdCookieEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;sessionIdCookie&quot; ref=&quot;sessionIdCookie&quot;/&gt; &lt;/bean&gt; &lt;!-- 会话验证调度器 --&gt; &lt;bean id=&quot;sessionValidationScheduler&quot; class=&quot;org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler&quot;&gt; &lt;property name=&quot;sessionValidationInterval&quot; value=&quot;1800000&quot;/&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;kickoutSessionControlFilter&quot; class=&quot;com.booway.shiro.KickoutSessionControlFilter&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot; /&gt; &lt;property name=&quot;kickoutAfter&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;maxSession&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;kickoutUrl&quot; value=&quot;/kickout.xhtml&quot; /&gt; &lt;/bean&gt; &lt;!-- Shiro Filter --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;com.booway.shiro.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;!-- 用于调用Controller --&gt; &lt;property name=&quot;service&quot; value=&quot;${uam.login.failurl}&quot; /&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;${cas.server.login.url}?service=&quot; /&gt; &lt;!-- 用户访问未授权页面后跳转的错误信息页面 --&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/401.html&quot;&gt;&lt;/property&gt; &lt;!-- 自己实现的formAuthcFilter，加入key type --&gt; &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;casFilter&quot; value-ref=&quot;casFilter&quot;&gt; &lt;/entry&gt; &lt;entry key=&quot;singleSignOutFilter&quot; value-ref=&quot;singleSignOutFilter&quot;&gt; &lt;/entry&gt; &lt;entry key=&quot;roles&quot; value-ref=&quot;roleFilter&quot;&gt; &lt;/entry&gt; &lt;entry key=&quot;kickout&quot; value-ref=&quot;kickoutSessionControlFilter&quot;&gt; &lt;/entry&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /** = singleSignOutFilter,casFilter,kickout &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;casFilter&quot; class=&quot;com.booway.shiro.MyCasFilter&quot;&gt; &lt;!-- 配置验证错误时的失败页面 --&gt; &lt;property name=&quot;failureUrl&quot; value=&quot;${uam.login.failurl}&quot; /&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/index.xhtml&quot; /&gt; &lt;property name=&quot;casLoginUrl&quot; value=&quot;${cas.server.login.url}&quot; /&gt; &lt;property name=&quot;interceptUrlPrefix&quot;&gt; &lt;list&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;loginUrls&quot;&gt; &lt;list&gt; &lt;value&gt;/index/login.xhtml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- &lt;property name=&quot;excludeUrls&quot;&gt; &lt;list&gt; &lt;value&gt;/index.xhtml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; --&gt; &lt;/bean&gt; &lt;bean id=&quot;userFilter&quot; class=&quot;com.booway.shiro.MyUserFilter&quot;&gt; &lt;!-- 配置验证错误时的失败页面 --&gt; &lt;property name=&quot;failureUrl&quot; value=&quot;${uam.login.failurl}&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;logoutFilter&quot; class=&quot;com.booway.shiro.MyLogoutFilter&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;roleFilter&quot; class=&quot;com.booway.shiro.RolesAuthorizationFilter&quot;&gt; &lt;/bean&gt; &lt;!-- 退出过滤器 --&gt; &lt;bean id=&quot;singleSignOutFilter&quot; class=&quot;com.booway.shiro.CustomSingleSignOutFilter&quot;&gt; &lt;/bean&gt; &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt; &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot; /&gt; &lt;!-- AOP式方法级权限检查 --&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on=&quot;lifecycleBeanPostProcessor&quot;&gt; &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt; &lt;property name=&quot;staticMethod&quot; value=&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot; /&gt; &lt;property name=&quot;arguments&quot; ref=&quot;securityManager&quot; /&gt; &lt;/bean&gt; &lt;!-- 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions), 需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证 --&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;/bean&gt; 这样一个shiro的拓展就完成啦！","tags":[{"name":"shiro","slug":"shiro","permalink":"http://yzy755.github.io/tags/shiro/"}]},{"title":"jvm调优总结 -Xms -Xmx -Xmn -Xss","date":"2017-03-24T09:50:48.000Z","path":"2017/03/24/jvm调优总结 -Xms -Xmx -Xmn -Xss/","text":"堆大小设置JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。我在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。典型设置：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k-Xmx3550m：设置JVM最大可用内存为3550M。-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。-Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6-XX:MaxPermSize=16m:设置持久代大小为16m。-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。 回收器选择JVM给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。吞吐量优先的并行收集器如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。典型配置：java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。响应时间优先的并发收集器如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。典型配置：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。-XX:+UseParNewGC:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片 辅助信息JVM提供了大量命令行参数，打印信息，供调试使用。主要有以下一些：-XX:+PrintGC输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]-XX:+PrintGCDetails输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]-XX:+PrintGCTimeStamps -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]-XX:+PrintGCApplicationConcurrentTime:打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用输出形式：Application time: 0.5291524 seconds-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用输出形式：Total time for which application threads were stopped: 0.0468229 seconds-XX:PrintHeapAtGC:打印GC前后的详细堆栈信息输出形式：34.702: [GC {Heap before gc invocations=7: def new generation total 55296K, used 52568K [0x1ebd0000, 0x227d0000, 0x227d0000)eden space 49152K, 99% used [0x1ebd0000, 0x21bce430, 0x21bd0000)from space 6144K, 55% used [0x221d0000, 0x22527e10, 0x227d0000) to space 6144K, 0% used [0x21bd0000, 0x21bd0000, 0x221d0000) tenured generation total 69632K, used 2696K [0x227d0000, 0x26bd0000, 0x26bd0000)the space 69632K, 3% used [0x227d0000, 0x22a720f8, 0x22a72200, 0x26bd0000) compacting perm gen total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000) the space 8192K, 35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000) ro space 8192K, 66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000) rw space 12288K, 46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)34.735: [DefNew: 52568K-&gt;3433K(55296K), 0.0072126 secs] 55264K-&gt;6615K(124928K)Heap after gc invocations=8: def new generation total 55296K, used 3433K [0x1ebd0000, 0x227d0000, 0x227d0000)eden space 49152K, 0% used [0x1ebd0000, 0x1ebd0000, 0x21bd0000) from space 6144K, 55% used [0x21bd0000, 0x21f2a5e8, 0x221d0000) to space 6144K, 0% used [0x221d0000, 0x221d0000, 0x227d0000) tenured generation total 69632K, used 3182K [0x227d0000, 0x26bd0000, 0x26bd0000)the space 69632K, 4% used [0x227d0000, 0x22aeb958, 0x22aeba00, 0x26bd0000) compacting perm gen total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000) the space 8192K, 35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000) ro space 8192K, 66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000) rw space 12288K, 46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)}, 0.0757599 secs]-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析。 常见配置汇总堆设置-Xms:初始堆大小-Xmx:最大堆大小-XX:NewSize=n:设置年轻代大小-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5-XX:MaxPermSize=n:设置持久代大小收集器设置-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器垃圾回收统计信息-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename并行收集器设置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)并发收集器设置-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。 四、调优总结年轻代大小选择响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。年老代大小选择响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：并发垃圾收集信息持久代并发收集次数传统GC信息花在年轻代和年老代回收上的时间比例减少年轻代和年老代花费的时间，一般会提高应用的效率吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。较小堆引起的碎片问题因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩","tags":[{"name":"jvm","slug":"jvm","permalink":"http://yzy755.github.io/tags/jvm/"},{"name":"调优","slug":"调优","permalink":"http://yzy755.github.io/tags/调优/"}]},{"title":"jvm内存分配","date":"2017-03-24T07:56:48.000Z","path":"2017/03/24/jvm内存分配/","text":"java内存组成介绍：堆(Heap)和非堆(Non-heap)内存 按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。 方法栈&amp;本地方法栈: 线程创建时产生,方法执行时生成栈帧 方法区 存储类的元数据信息 常量等 堆 java代码中所有的new操作 native Memory(C heap) Direct Bytebuffer JNI Compile GC; 堆内存分配 JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由-Xmx指 定，默认是物理内存的1/4。默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。 组成 详解 Young Generation 即图中的Eden + From Space + To Space Eden 存放新生的对象 Survivor Space 有两个，存放每次垃圾回收后存活的对象 Old Generation Tenured Generation 即图中的Old Space 主要存放应用程序中生命周期长的存活对象 非堆内存分配 JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。 组成 详解 Permanent Generation 保存虚拟机自己的静态(refective)数据 主要存放加载的Class类级别静态对象如class本身，method，field等等 permanent generation空间不足会引发full GC(详见HotSpot VM GC种类) Code Cache 用于编译和保存本地代码（native code）的内存 JVM内部处理或优化 JVM内存限制(最大值) JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽然 可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，Linux系统 下为2G-3G），而64bit以上的处理器就不会有限制了。","tags":[{"name":"jvm","slug":"jvm","permalink":"http://yzy755.github.io/tags/jvm/"},{"name":"内存分配","slug":"内存分配","permalink":"http://yzy755.github.io/tags/内存分配/"}]},{"title":"linux环境下ffmpeg加入libx264编译方法","date":"2017-03-10T08:50:48.000Z","path":"2017/03/10/linux环境下ffmpeg加入libx264编译方法/","text":"下载源码 libx264 http://download.videolan.org/x264/snapshots/ 最新版 yasm http://yasm.tortall.net/Download.html 版本为yasm-1.3.0(yasm是汇编编译器,因为ffmpeg中为了提高效率用到了汇编指令) ffmpeg http://www.ffmpeg.org/download.html 版本为ffmpge-2.6.3编译 yasm解压yasm-1.3.0至当前目录tar -zxvf yasm.1.3.0.tar.gzcd yasm./configure –prefix=/usr/local/yasmmakemake install libx264解压x264-snapshot-20140424-2245.tar至当前目录tar -zxvf x264-snapshot-20140424-2245.tarcd x264./configure –prefix=/usr/local/x264 –enable-shared –enable-static –enable-yasmmakemake install ffmpeg解压ffmpeg-2.8.0.tar至当前目录tar -zxvf ffmpeg-2.8.0.tarcd ffmpeg./configure –prefix=/usr/local/ffmpeg –enable-shared –enable-libx264 –enable-gpl –enable-pthreads –extra-cflags=-I/usr/local/x264/include –extra-ldflags=-L/usr/local/x264/libmakemake install容易出现的问题error while loading shared libraries: libpostproc.so.53（libx264.so.148）: cannot open shared object file: No such file or directory运行 ldd $(which ffmpeg) 命令 ps:ldd命令用于判断某个可执行的 binary 档案含有什么动态函式库在linux下安装ffmpeg出现此问题运行改命令示例：linux-vdso.so.1 =&gt; (0x00007fff6173b000) libavdevice.so.56 =&gt; /usr/local/ffmpeg/lib/libavdevice.so.56 (0x00007f61761fc000) libavfilter.so.5 =&gt; /usr/local/ffmpeg/lib/libavfilter.so.5 (0x00007f6175e70000) libavformat.so.56 =&gt; /usr/local/ffmpeg/lib/libavformat.so.56 (0x00007f6175a8c000) libavcodec.so.56 =&gt; /usr/local/ffmpeg/lib/libavcodec.so.56 (0x00007f61745eb000) libpostproc.so.53 =&gt; not found libswresample.so.1 =&gt; /usr/local/ffmpeg/lib/libswresample.so.1 (0x00007f61743cf000) libswscale.so.3 =&gt; /usr/local/ffmpeg/lib/libswscale.so.3 (0x00007f617413e000) libavutil.so.54 =&gt; /usr/local/ffmpeg/lib/libavutil.so.54 (0x00007f6173ed7000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f6173c52000) libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f6173a35000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f61736a1000) libpostproc.so.53 =&gt; not found libz.so.1 =&gt; /lib64/libz.so.1 (0x00007f617348a000) libx264.so.148 =&gt; not found librt.so.1 =&gt; /lib64/librt.so.1 (0x00007f6173281000) /lib64/ld-linux-x86-64.so.2 (0x00007f617641c000)可以看到libpostproc.so.53和libx264.so.148 not found出现这类错误表示，系统不知道xxx.so放在哪个目录下，这时候就要在/etc/ld.so.conf中加入xxx.so所在的目录。一般而言，有很多的so会存放在/usr/local/lib这个目录底下，去这个目录底下找，果然发现自己所需要的.so文件。所以，在/etc/ld.so.conf中加入/usr/local/lib这一行，保存之后，再运行：/sbin/ldconfig –v(或者直接运行ldconfig命令)更新一下配置即可。","tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://yzy755.github.io/tags/ffmpeg/"},{"name":"编译","slug":"编译","permalink":"http://yzy755.github.io/tags/编译/"}]},{"title":"hexo编辑博客整理","date":"2017-03-08T07:56:48.000Z","path":"2017/03/08/hexo编辑博客整理/","text":"一.Hexo搭建Github-Pages博客 1.安装nodejs和git,方法略 2.安装hexo $ npm install -g hexo 3.部署hexo $ hexo init . ├── .deploy ├── public ├── scaffolds ├── scripts ├── source | ├── _drafts | └── _posts ├── themes ├── _config.yml └── package.json .deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 _drafts：草稿文章 _posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 4.Hexo命令 Hexo下，通过 _config.yml 设置博客，可以想象成我们用的软件里的设置一样，只是它通过一个文件列出这些参数，然后让我们填写和修改。 全局设置 在你博客目录下有一个文件名_config.yml，打开可以配置信息。 局部页面 在你博客目录下 \\themes\\你使用的主题\\_config.yml 写博客相关命令 Hexo常用命令： hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub 当然，如果每次输入那么长命令，那么一定想到用简写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 其它的，还可以复合命令： hexo deploy -g hexo server -g 有时候生成的网页出错了，而生成的rss其实没有清除，那么用下面的命令，在重新生成吧 $ hexo clean 当本地调试出现诡异现象时候，请先使用 hexo clean 清理已经生成的静态文件后重试。 注：Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了README.md，它也会在你下一次部署时被删去。怎么解决呢？ 在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。 5.博客管理 上面命令中，其实生成文章，可以直接把写好的文章插入到目录/_posts 下面，后缀为.MD就行，在文章头部固定格式： title: Mac提高使用效率的一些方法 #文章的标题，这个才是显示的文章标题，其实文件名不影响 date: 2015-09-01 20:33:26 #用命令会自动生成，也可以自己写，所以文章时间可以改 categories: technology #文章的分类，这个可以自己定义 tags: [Mac,效率,快捷方式] #tag，为文章添加标签，方便搜索 --- 当然，里面有很多东西的，如果你专注于写作，那么可以不用太关心了，比如tags标签可以写成下面那样，因为hexo文章的头部文件是用AML来写的。 tags: - tag1 - tag2 如果在博客文章列表中，不想全文显示，可以增加 &lt;!--more--&gt;, 后面的内容就不会显示在列表。 &lt;!--more--&gt; 6.插件 安装插件 $ npm install &lt;plugin-name&gt; --save 添加RSS npm install hexo-generator-feed 然后，到博客目录 /public 下，如果没有发现atom.xml，说明命令没有生效！！！(楼主就是在这里被坑了次) 解决方法： $ npm install hexo-generator-feed --save 这个命令来自hexo-generator-feed Install $ npm install hexo-generator-feed --save Hexo 3: 1.x Hexo 2: 0.x Options You can configure this plugin in _config.yml. feed: type: atom path: atom.xml limit: 20 type - Feed type. (atom/rss2) path - Feed path. (Default: atom.xml/rss2.xml) limit - Maximum number of posts in the feed (Use 0 or false to show all posts) 其中可以选择： 然后在 Hexo 根目录下的 _config.yml 里配置一下 feed: type: atom path: atom.xml limit: 20 #type 表示类型, 是 atom 还是 rss2. #path 表示 Feed 路径 #limit 最多多少篇最近文章 最后，在 hexo generate之后，会发现public文件夹下多了atom.xml！ 例如要订阅我的blog只要输入ihtc.cc/atom就可以搜寻到啦！ 添加Sitemap Sitemap 的提交主要的目的，是要避免搜索引擎的爬虫没有完整的收录整个网页的内容，所以提交 Sitemap 是能够补足搜索引擎的不足，进而加速网页的收录速度，达到搜寻引擎友好的目的。 $ npm install hexo-generator-sitemap --save 这个命令来自hexo-generator-sitemap Install $ npm install hexo-generator-sitemap --save Hexo 3: 1.x Hexo 2: 0.x Options You can configure this plugin in _config.yml. sitemap: path: sitemap.xml path - Sitemap path. (Default: sitemap.xml) 同样可以选择： 在 Hexo 根目录下的 _config.yml 里配置一下 sitemap: path: sitemap.xml #path 表示 Sitemap 的路径. 默认为 sitemap.xml. 对于国内用户还需要安装插件 hexo-generator-baidu-sitemap, 顾名思义是为百度量身打造的. 安装 $ npm install hexo-generator-baidu-sitemap --save 然后在 Hexo 根目录下的 _config.yml 里配置一下 baidusitemap: path: baidusitemap.xml 为了博客有更好的展示率, 最好的方式是通过搜索引擎, 提交 Sitemap文件是一个方式，具体可参考： Hexo 优化与定制(二) | Kang Lu&apos;s Blog ｜Hexo优化｜如何向google提交sitemap（详细） | Fiona&apos;s Blog 其它插件 Plugins · hexojs/hexo 7.评论设置 在Hexo中，默认使用的评论是国外的Disqus,不过因为国内的”网络环境”问题，我们改为国内的多说评论系统。 需要说明的是 short_name:字段，这个字段为你多说填写的站点名字，比如我的域名：ihtcboy.duoshuo.com，那么我的short_name:&quot;ihtcboy&quot; 8.404页面 GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的404.html就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。 其实，404页面可以做更多有意义的事，来做个404公益项目吧。 腾讯公益 404.html : &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;404&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt;&lt;!-- &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;公益404 | 不如&lt;/title&gt; &lt;/head&gt; &lt;body&gt; #404 Not found By Bruce &lt;h1&gt;404 Page Not Found&lt;/h1&gt; --&gt;&lt;br&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;br&gt;&lt;!-- 公益404介接入地址 益云公益404 http://yibo.iyiyun.com/Index/web404 腾讯公益404 http://www.qq.com/404 失蹤兒童少年資料管理中心404 http://404page.missingkids.org.tw --&gt; &lt;br&gt; &lt;/body&gt; &lt;/html&gt; 复制上面代码，贴粘到目录下新建的404.html即可！ 9.统计 因Google Analytics偶尔被墙，故国内用百度统计 最新的统计服务已经开放，两行代码轻松搞定，你可以直接使用：不蒜子 本人墙裂推荐，只需要两行代码哦。各种用法实例和显示效果参考不蒜子文档中的实例链接。不蒜子，极客的算子，极简的算子，任你发挥的算子。 10.更新 更新hexo： npm update -g hexo 更新主题： cd themes/你的主题 git pull 更新插件： npm update 11.在 hexo 中无痛使用本地图片 首先确认 _config.yml 中有 post_asset_folder:true 在 hexo 目录，执行 npm install https://github.com/CodeFalling/hexo-asset-image --save 假设在 MacGesture2-Publish ├── apppicker.jpg ├── logo.jpg └── rules.jpg MacGesture2-Publish.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](MacGesture2-Publish/logo.jpg) 就可以插入图片。 生成的结构为 public/2015/10/18/MacGesture2-Publish ├── apppicker.jpg ├── index.html ├── logo.jpg └── rules.jpg 同时，生成的 html 是 &lt;img src=&quot;/2015/10/18/MacGesture2-Publish/logo.jpg&quot; alt=&quot;logo&quot;&gt; 12.添加评论插件 在_config.yml中添加多说的配置： duoshuo_shortname: 你站点的short_name ps:只需要写你注册填写的内容 修改themes\\landscape\\layout\\_partial\\article.ejs模板 把 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt; &lt;% } %&gt; 改为 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&apos;&lt;%= config.duoshuo_shortname %&gt;&apos;}; (function() { var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; &lt;% } %&gt;","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yzy755.github.io/tags/hexo/"}]},{"title":"zookeeper浅读","date":"2017-03-08T07:44:27.000Z","path":"2017/03/08/zookeeper浅读/","text":"下面我们来看下开源dubbo推荐的业界成熟的zookeeper做为注册中心， zookeeper是hadoop的一个子项目是分布式系统的可靠协调者，他提供了配置维护，名字服务，分布式同步等服务。对于zookeeper的原理本文档不分析，后面有时间在做专题。zookeeper注册中心Zookeeper对数据存储类似linux的目录结构，下面给出官方文档对dubbo注册数据的存储示例 假设读者对zookeeper有所了解，能够搭建zookeeper服务，其实不了解也没关系，谷歌百度下分分钟搞起。作为测试调试dubbo，我是在本地起的zookeeper 指定zookeeper配置文件地址 配置文件中两个关键参数：dataDir zookeeper存储文件的地址clientPort 客户端链接的端口号Dubbo服务提供者配置 除了配置注册中心的，其他都一样Dubbo服务消费者配置","tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://yzy755.github.io/tags/zookeeper/"}]},{"title":"TCP的几个状态码","date":"2017-03-08T03:48:05.000Z","path":"2017/03/08/TCP的几个状态码/","text":"在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG. 其中，对于我们日常的分析有用的就是前面的五个字段。 它们的含义是： SYN表示建立连接， FIN表示关闭连接， ACK表示响应， PSH表示有 DATA数据传输， RST表示连接重置。 其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应， 如果只是单个的一个SYN，它表示的只是建立连接。 TCP的几次握手就是通过这样的ACK表现出来的。 但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。 RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。 一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。 PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。 TCP的连接建立和连接关闭，都是通过请求－响应的模式完成的。 概念补充-TCP三次握手：TCP(Transmission Control Protocol)传输控制协议TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接： 位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包；第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。完成三次握手，主机A与主机B开始传送数据。TCP采用三次握手建立连接如下图所示。用大白话就是这样： 在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据. 关闭连接：由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。 （1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 （2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 （3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 （4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 TCP采用四次挥手关闭连接如下图所示。","tags":[{"name":"tcp","slug":"tcp","permalink":"http://yzy755.github.io/tags/tcp/"},{"name":"三次握手","slug":"三次握手","permalink":"http://yzy755.github.io/tags/三次握手/"},{"name":"四次挥手","slug":"四次挥手","permalink":"http://yzy755.github.io/tags/四次挥手/"}]},{"title":"jar包在windows下的运行命令","date":"2017-03-02T09:17:53.000Z","path":"2017/03/02/jar包在windows下运行命令/","text":"1、打jar包 jar -cvf xx.jar 文件夹名称 说明一下：.表示把当前目录下面以及子目录的所有class都打到这个xx.jar里。 -cvf的含义，可以自己去用jar命令去查看 如果要单独对某个或某些class文件进行打包，可以这样： jar -cvf xx.jar Foo.class Bar.class 2.运行jar java -jar xx.jar 要运行一个jar，则此jar内部的META-INF\\MANIFEST.MF文件里必须指明要执行的main方法类 具体格式如： Manifest-Version: 1.0Created-By: 1.6.0_03 (Sun Microsystems Inc.)Main-class: Test如果此处的Test.class在com.xx包下面，则需要指明。 如果在运行时报了invalid or corrupt jarfile错误，则需要检查Main-class: Test 之间是不是缺少了空格。 3.指定运行jar里面的class java -cp xx.jar com.xx.Test 4.编译某个java文件，但是依赖某个jar javac -cp xx.jar Test.java (Test.java里面import了xx.jar里面的某个class) 5.运行某个java文件，但是依赖某个jar java -cp .;xx.jar Test 注意：引用xx.jar的时候，不要漏掉.;（这个表示当前目录）","tags":[{"name":"java","slug":"java","permalink":"http://yzy755.github.io/tags/java/"},{"name":"jar包","slug":"jar包","permalink":"http://yzy755.github.io/tags/jar包/"}]},{"title":"solr部署","date":"2017-03-02T09:17:53.000Z","path":"2017/03/02/solr部署/","text":"http://www.tuicool.com/articles/mueARf 参考 请下载tgz包而不是zip包，特此提醒！ 解压solr-5.1.0.zip到任意盘符，如图： 复制solr.war到tomcat的webapps目录下，如图操作： 启动tomcat,如图：然后修改webapps\\solr\\WEB-INF下的web.xml配置文件，如图： 配置solr_home目录路径，如图： 然后我们需要去C盘创建一个solr_home文件夹，这就是我们SOLR_HOME根目录啦，如图： 然后我们需要把E:\\solr-5.1.0\\server\\solr目录下的所有文件及文件夹全部复制到我们刚刚创建的solr_home目录下，如图： 然后我们需要把E:\\solr-5.1.0\\server\\lib\\ext目录下的所有jar包 copy到E:\\apache-tomcat-7.0.55\\webapps\\solr\\WEB-INF\\lib目录下(E:\\apache-tomcat-7.0.55是我的tomcat安装根目录，请对照你们自己的tomcat安装目录进行调整，你懂的)，如图： 然后复制 E:\\solr-5.1.0\\server\\resources目录下的log4j.properties配置文件到E:\\apache-tomcat-7.0.55\\webapps\\solr\\WEB-INF目录下，如图操作： 然后重启我们的tomcat,如图： 打开你的浏览器，地址栏输入 http://localhost:8080/solr ， 访问我们的Solr Web后台。如果你能看到这个界面，即表明Solr5部署成功了，如图： 然后你就可以通过Solr Web UI添加Core啦，不过添加Core之前，你需要在solr_home目录下创建core文件夹，如图：core目录下需要创建conf和data文件夹，你懂的， 《跟益达学Solr5之使用Jetty部署Solr》这篇博客也提到过，如图： 剩下的一些配置copy具体你们就参照那篇去操作把，这里就不重复说明了。到此，Solr5如何部署到Tomcat就讲解完毕了！ IK 分词器安装1.将之前解压的solr-4.3.1 下的contrib和dist 文件夹复制到F:\\winsolr\\solr_home\\solr\\collection1下2.将下载的IKAnalyzer的发行包解压，解压后将IKAnalyzer2012FF_u1.jar（分词器jar包）复制到F:\\winsolr\\solr_home\\solr\\collection1\\contrib\\analysis-extras\\lib下3.在F:\\winsolr\\apache-tomcat-7.0.37\\webapps\\solr\\WEB-INF下新建classes文件夹4.将IKAnalyzer解压出来的IKAnalyzer.cfg.xml（分词器配置文件）和 Stopword.dic（分词器停词字典,可自定义添加内容）复制到 F:\\winsolr\\apache-tomcat-7.0.37\\webapps\\solr\\WEB-INF\\classes中5.在F:\\winsolr\\solr_home\\solr\\collection1\\conf下的schema.xml文件中fieldType name=”text_general”这个地方的上方添加以下内容 将pinyinfj.jar、lucene-analyzers-smartcn-4.7.0.jar、IKAnalyzer2012FF_u1.jar、pinyinAnalyzer.jar、shentong_tsearch_lib.jar放到solr部署目录的web-inf的lib目录下","tags":[{"name":"solr","slug":"solr","permalink":"http://yzy755.github.io/tags/solr/"}]},{"title":"微信小程序对接支付","date":"2017-03-02T09:17:53.000Z","path":"2017/03/02/微信小程序对接支付/","text":"所有支付方式都需要通过 「统一下单」的 API 来获取一个支付凭证。但在小程序内测期间，还没有「统一下单」的概念。HTML 5 应用发起支付需要直接通过前端构造参数来发起（不经过后端验证），很容易造成支付凭证泄露等安全问题。为此，微信支付将其流程进行了优化：在所有支付场景中插入「统一下单」的特性。推荐开发者在后端完成支付参数的构建等行为。该优化带来以下好处: * 尽可能让开发者不犯低级错误，造成财务损失。 * 简化构造支付参数的复杂度，所有支付方式可共享一个支付后端接口。 通过「统一下单」获取到相对应 prepay_id 或者 code_url 等参数，即可通过各种支付模式的 SDK 来进行微信支付的发起。需要注意的是，必须对通知参数进行签名验证，以确保安全。进行签名验证时，除去签名字段（一般参数名为: sign）不需要参与签名外，其余所有接收到的参数均需要参与签名。比如拼接的请求支付宝的参数为total_fee,body,appid，那么签名就必须用这三个参数得到prepay_id后还需在发起wx.requestPayment前对 wx.requestPayment请求所需的参数进行签名所需的参数为’timeStamp’: res.data.timeStamp, ‘nonceStr’: nonce_str, ‘package’: ‘prepay_id=’+prepay_id, ‘signType’: ‘MD5’, ‘paySign’: res.data.sign,但是后台生成该签名还需appId（I大写！！）随后用返回的参数和生成的timeStamp进行请求（ appId、timeStamp、nonceStr、package、signType）。 之后又将微信支付集成到了web端，官方对于网页版的微信支付有两种模式，我使用的是更为简单的模式二，参考https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_5时序图如下：与小程序的统一下单api所需的参数不同的是：小程序的trade_type一定是”JSAPI”,相应的一定要传当前使用小程序的用户openid；扫码支付模式二的trade_type是”NATIVE”，不需要用户的openid,其他参数相同，为： wxRequestParam.setAppid(ConstantUtil.APP_ID); wxRequestParam.setMch_id(ConstantUtil.MCH_ID); wxRequestParam.setNonce_str(WXUtil.getNonceStr()); wxRequestParam.setBody(commonsOrder.getTitle()); wxRequestParam.setSpbill_create_ip(request.getRemoteAddr().startsWith(“0”)?”127.0.0.1”:request.getRemoteAddr()); wxRequestParam.setOut_trade_no(commonsOrder.getOrderCode()); wxRequestParam.setTotal_fee(StringUtils.substringBefore(String.valueOf(commonsOrder.getOrderFee().setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue() * 100), “.”)); wxRequestParam.setNotify_url(ConstantUtil.NOTIFY_URL); wxRequestParam.setSign(sign); wxRequestParam.setTrade_type(“NATIVE”); // 下面是小程序不同的参数 wxRequestParam.setOpenid(openid); wxRequestParam.setTrade_type(“JSAPI”); 统一下单后返回参数中有一个code_url，使用 http://qr.liantu.com/api.php?text=code_url 即可看到一张二维码，扫码就支付啦，是不是比较简单- - ——————————————–2017.4.6更新——————————————————老大说使用其他网站平台生成二维码感觉不靠谱，所以去网上看了下有没有自己“画”二维码的库类，当然是有的，google爸爸就有一套基于nio的图片制作工具：添加依赖： &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; 编写工具类，代码如下： /** * @param qrImagePath 生成的图片绝对路径 * @param qrImageName 生成的图片名称 * @param content 待扫描的内容 * @throws WriterException * @throws IOException */ public static String createQRcode(String qrImagePath, String qrImageName, String content) throws WriterException, IOException { int width = 300; // 图像宽度 int height = 300; // 图像高度 String format = &quot;png&quot;;// 图像类型 Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;EncodeHintType, Object&gt;(); hints.put(EncodeHintType.CHARACTER_SET, &quot;UTF-8&quot;); BitMatrix bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, width, height, hints);// 生成矩阵 Path path = FileSystems.getDefault().getPath(qrImagePath, qrImageName); MatrixToImageWriter.writeToPath(bitMatrix, format, path);// 输出图像 return path.toString(); } // 原来的生成方法 public static String QRfromLiantu(String chl) throws Exception { chl = UrlEncode(chl); String QRfromLiantu = &quot;http://qr.liantu.com/api.php?text=&quot; + chl; return QRfromLiantu; } // 特殊字符处理 public static String UrlEncode(String src) throws UnsupportedEncodingException { return URLEncoder.encode(src, &quot;UTF-8&quot;).replace(&quot;+&quot;, &quot;%20&quot;); } 然后调用就简单啦，消除领导的顾虑看了下京东的微信二维码支付，一分钟刷新一次，有自己独立的二维码服务，后期抽空研究下。。。","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yzy755.github.io/tags/微信小程序/"},{"name":"微信支付","slug":"微信支付","permalink":"http://yzy755.github.io/tags/微信支付/"}]}]