<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的博客</title>
  <subtitle>一天进步一点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yzy755.github.io/"/>
  <updated>2017-03-09T09:51:32.491Z</updated>
  <id>http://yzy755.github.io/</id>
  
  <author>
    <name>易泽源</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo编辑博客整理</title>
    <link href="http://yzy755.github.io/2017/03/08/hexo%E7%BC%96%E8%BE%91%E5%8D%9A%E5%AE%A2%E6%95%B4%E7%90%86/"/>
    <id>http://yzy755.github.io/2017/03/08/hexo编辑博客整理/</id>
    <published>2017-03-08T07:56:48.000Z</published>
    <updated>2017-03-09T09:51:32.491Z</updated>
    
    <content type="html"><![CDATA[<p>一.Hexo搭建Github-Pages博客<br>   1.安装nodejs和git,方法略</p>
<p>   2.安装hexo<br>       $ npm install -g hexo<br><a id="more"></a><br>   3.部署hexo<br>       $ hexo init<br>       .<br>        ├── .deploy<br>        ├── public<br>        ├── scaffolds<br>        ├── scripts<br>        ├── source<br>        |   ├── _drafts<br>        |   └── _posts<br>        ├── themes<br>        ├── _config.yml<br>        └── package.json<br>        .deploy：执行hexo deploy命令部署到GitHub上的内容目录<br>        public：执行hexo generate命令，输出的静态网页内容目录<br>        scaffolds：layout模板文件目录，其中的md文件可以添加编辑<br>        scripts：扩展脚本目录，这里可以自定义一些javascript脚本<br>        source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。<br>        _drafts：草稿文章<br>        _posts：发布文章<br>        themes：主题文件目录<br>        _config.yml：全局配置文件，大多数的设置都在这里<br>        package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</p>
<pre><code>4.Hexo命令
    Hexo下，通过 _config.yml 设置博客，可以想象成我们用的软件里的设置一样，只是它通过一个文件列出这些参数，然后让我们填写和修改。

    全局设置
    在你博客目录下有一个文件名_config.yml，打开可以配置信息。

    局部页面
    在你博客目录下 \themes\你使用的主题\_config.yml

    写博客相关命令
        Hexo常用命令：
        hexo new &quot;postName&quot;       #新建文章
        hexo new page &quot;pageName&quot;  #新建页面
        hexo generate             #生成静态页面至public目录
        hexo server               #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
        hexo deploy               #将.deploy目录部署到GitHub

    当然，如果每次输入那么长命令，那么一定想到用简写：
        hexo n == hexo new
        hexo g == hexo generate
        hexo s == hexo server
        hexo d == hexo deploy

    其它的，还可以复合命令：
        hexo deploy -g
        hexo server -g

    有时候生成的网页出错了，而生成的rss其实没有清除，那么用下面的命令，在重新生成吧
        $ hexo clean

    当本地调试出现诡异现象时候，请先使用 hexo clean 清理已经生成的静态文件后重试。

    注：Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了README.md，它也会在你下一次部署时被删去。怎么解决呢？
    在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。

5.博客管理
    上面命令中，其实生成文章，可以直接把写好的文章插入到目录/_posts 下面，后缀为.MD就行，在文章头部固定格式：
        title: Mac提高使用效率的一些方法   #文章的标题，这个才是显示的文章标题，其实文件名不影响
        date: 2015-09-01 20:33:26      #用命令会自动生成，也可以自己写，所以文章时间可以改
        categories: technology         #文章的分类，这个可以自己定义
        tags: [Mac,效率,快捷方式]        #tag，为文章添加标签，方便搜索
        ---
    当然，里面有很多东西的，如果你专注于写作，那么可以不用太关心了，比如tags标签可以写成下面那样，因为hexo文章的头部文件是用AML来写的。
        tags:
        - tag1
        - tag2
    如果在博客文章列表中，不想全文显示，可以增加 &lt;!--more--&gt;, 后面的内容就不会显示在列表。
         &lt;!--more--&gt;

6.插件
    安装插件
      $ npm install &lt;plugin-name&gt; --save
    添加RSS

      npm install hexo-generator-feed
    然后，到博客目录 /public 下，如果没有发现atom.xml，说明命令没有生效！！！(楼主就是在这里被坑了次)
    解决方法：
      $ npm install hexo-generator-feed --save
    这个命令来自hexo-generator-feed

      Install
         $ npm install hexo-generator-feed --save
       Hexo 3: 1.x
       Hexo 2: 0.x
      Options
         You can configure this plugin in _config.yml.

        feed:
           type: atom
           path: atom.xml
           limit: 20

          type - Feed type. (atom/rss2)
          path - Feed path. (Default: atom.xml/rss2.xml)
          limit - Maximum number of posts in the feed (Use 0 or false to show all posts)
    其中可以选择：
    然后在 Hexo 根目录下的 _config.yml 里配置一下

        feed:
            type: atom
            path: atom.xml
            limit: 20
        #type 表示类型, 是 atom 还是 rss2.
        #path 表示 Feed 路径
        #limit 最多多少篇最近文章
    最后，在 hexo generate之后，会发现public文件夹下多了atom.xml！

    例如要订阅我的blog只要输入ihtc.cc/atom就可以搜寻到啦！

    添加Sitemap
    Sitemap 的提交主要的目的，是要避免搜索引擎的爬虫没有完整的收录整个网页的内容，所以提交 Sitemap 是能够补足搜索引擎的不足，进而加速网页的收录速度，达到搜寻引擎友好的目的。
        $ npm install hexo-generator-sitemap --save
    这个命令来自hexo-generator-sitemap

        Install
            $ npm install hexo-generator-sitemap --save

            Hexo 3: 1.x
            Hexo 2: 0.x
        Options
            You can configure this plugin in _config.yml.

            sitemap:
                path: sitemap.xml
            path - Sitemap path. (Default: sitemap.xml)
    同样可以选择：
    在 Hexo 根目录下的 _config.yml 里配置一下

            sitemap:
               path: sitemap.xml
               #path 表示 Sitemap 的路径. 默认为 sitemap.xml.
    对于国内用户还需要安装插件 hexo-generator-baidu-sitemap, 顾名思义是为百度量身打造的. 安装

            $ npm install hexo-generator-baidu-sitemap --save
    然后在 Hexo 根目录下的 _config.yml 里配置一下

           baidusitemap:
                path: baidusitemap.xml
    为了博客有更好的展示率, 最好的方式是通过搜索引擎, 提交 Sitemap文件是一个方式，具体可参考：

    Hexo 优化与定制(二) | Kang Lu&apos;s Blog
    ｜Hexo优化｜如何向google提交sitemap（详细） | Fiona&apos;s Blog

    其它插件
    Plugins · hexojs/hexo

7.评论设置
    在Hexo中，默认使用的评论是国外的Disqus,不过因为国内的”网络环境”问题，我们改为国内的多说评论系统。
    需要说明的是 short_name:字段，这个字段为你多说填写的站点名字，比如我的域名：ihtcboy.duoshuo.com，那么我的short_name:&quot;ihtcboy&quot;

8.404页面
    GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的404.html就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。
    其实，404页面可以做更多有意义的事，来做个404公益项目吧。
    腾讯公益 404.html :

        &lt;html&gt;
        &lt;head&gt;   
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;404&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;br&gt;&lt;!--
        &lt;!DOCTYPE HTML&gt;
        &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot; /&gt;
            &lt;title&gt;公益404 | 不如&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
        #404 Not found By Bruce
        &lt;h1&gt;404 Page Not Found&lt;/h1&gt;
        --&gt;&lt;br&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;br&gt;&lt;!--
        公益404介接入地址
        益云公益404 http://yibo.iyiyun.com/Index/web404
        腾讯公益404 http://www.qq.com/404
        失蹤兒童少年資料管理中心404 http://404page.missingkids.org.tw
        --&gt;
        &lt;br&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    复制上面代码，贴粘到目录下新建的404.html即可！

9.统计
    因Google Analytics偶尔被墙，故国内用百度统计
    最新的统计服务已经开放，两行代码轻松搞定，你可以直接使用：不蒜子
    本人墙裂推荐，只需要两行代码哦。各种用法实例和显示效果参考不蒜子文档中的实例链接。不蒜子，极客的算子，极简的算子，任你发挥的算子。

10.更新
    更新hexo：
      npm update -g hexo
    更新主题：
      cd themes/你的主题
      git pull
    更新插件：
      npm update

11.在 hexo 中无痛使用本地图片
    首先确认 _config.yml 中有 post_asset_folder:true

    在 hexo 目录，执行

    npm install https://github.com/CodeFalling/hexo-asset-image --save

    假设在
    MacGesture2-Publish
    ├── apppicker.jpg
    ├── logo.jpg
    └── rules.jpg
    MacGesture2-Publish.md
    这样的目录结构（目录名和文章名一致），只要使用 ![logo](MacGesture2-Publish/logo.jpg) 就可以插入图片。

    生成的结构为
    public/2015/10/18/MacGesture2-Publish
    ├── apppicker.jpg
    ├── index.html
    ├── logo.jpg
    └── rules.jpg
    同时，生成的 html 是
    &lt;img src=&quot;/2015/10/18/MacGesture2-Publish/logo.jpg&quot; alt=&quot;logo&quot;&gt;

12.添加评论插件
    在_config.yml中添加多说的配置：
      duoshuo_shortname: 你站点的short_name ps:只需要写你注册填写的内容

      修改themes\landscape\layout\_partial\article.ejs模板
    把

      &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt;
      &lt;section id=&quot;comments&quot;&gt;
        &lt;div id=&quot;disqus_thread&quot;&gt;
          &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;
        &lt;/div&gt;
      &lt;/section&gt;
      &lt;% } %&gt;
    改为

      &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname){ %&gt;
      &lt;section id=&quot;comments&quot;&gt;
        &lt;!-- 多说评论框 start --&gt;
        &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt;
        &lt;!-- 多说评论框 end --&gt;
        &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
        var duoshuoQuery = {short_name:&apos;&lt;%= config.duoshuo_shortname %&gt;&apos;};
          (function() {
            var ds = document.createElement(&apos;script&apos;);
            ds.type = &apos;text/javascript&apos;;ds.async = true;
            ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;;
            ds.charset = &apos;UTF-8&apos;;
            (document.getElementsByTagName(&apos;head&apos;)[0] 
             || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds);
          })();
          &lt;/script&gt;
        &lt;!-- 多说公共JS代码 end --&gt;
      &lt;/section&gt;
      &lt;% } %&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一.Hexo搭建Github-Pages博客&lt;br&gt;   1.安装nodejs和git,方法略&lt;/p&gt;
&lt;p&gt;   2.安装hexo&lt;br&gt;       $ npm install -g hexo&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yzy755.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://yzy755.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper浅读</title>
    <link href="http://yzy755.github.io/2017/03/08/zookeeper%E6%B5%85%E8%AF%BB/"/>
    <id>http://yzy755.github.io/2017/03/08/zookeeper浅读/</id>
    <published>2017-03-08T07:44:27.000Z</published>
    <updated>2017-03-09T09:12:33.717Z</updated>
    
    <content type="html"><![CDATA[<p>下面我们来看下开源dubbo推荐的业界成熟的zookeeper做为注册中心， zookeeper是hadoop的一个子项目是分布式系统的可靠协调者，他提供了配置维护，名字服务，分布式同步等服务。对于zookeeper的原理本文档不分析，后面有时间在做专题。<br>zookeeper注册中心<br>Zookeeper对数据存储类似linux的目录结构，下面给出官方文档对dubbo注册数据的存储示例<br><a id="more"></a><br><img src="/2017/03/08/zookeeper浅读/1.png" alt="logo"></p>
<p>假设读者对zookeeper有所了解，能够搭建zookeeper服务，其实不了解也没关系，谷歌百度下分分钟搞起。<br>作为测试调试dubbo，我是在本地起的zookeeper<br><img src="/2017/03/08/zookeeper浅读/2.png" alt="logo"></p>
<p>指定zookeeper配置文件地址<br><img src="/2017/03/08/zookeeper浅读/3.png" alt="logo"></p>
<p>配置文件中两个关键参数：<br>dataDir zookeeper存储文件的地址<br>clientPort 客户端链接的端口号<br>Dubbo服务提供者配置</p>
<p><dubbo:registry protocol="”" zookeeper="" ”="" address="127.0.0. 1: 2181 "></dubbo:registry></p>
<p><beanid="demoservice" class="com.alibaba.dubbo.demo.provi der.DemoServiceImpl"></beanid="demoservice"></p>
<p><dubbo:serviceinterface="com.alibaba.dubbo.demo.demoservi ce"="" ref="demoService"><br>除了配置注册中心的，其他都一样<br>Dubbo服务消费者配置</dubbo:serviceinterface="com.alibaba.dubbo.demo.demoservi></p>
<p><dubbo:registry protocol="”" zookeeper="" ”="" address="127.0.0. 1: 2181 "></dubbo:registry></p>
<p><dubbo:reference id="demoService" interface="com.alibaba.dubbo.demo.DemoService"><br>除了配置注册中心的，其他都一样<br>客户端获取注册器<br>服务的提供者和消费者在RegistryProtocol利用注册中心暴露(export)和引用(refer)服务的时候会根据配置利用Dubbo的SPI机制获取具体注册中心注册器<br>Registry registry = registryFactory .getRegistry(url);<br>这里的RegistryFactory是ZookeeperRegistryFactory看如下工厂代码<br>public class ZookeeperRegistryFactory extends AbstractRegistryFactory {<br>    public Registry createRegistry(URL url) {<br>        return new ZookeeperRegistry(url, zookeeperTransporter );<br>    }<br>}<br>这里创建zookeepr注册器ZookeeperRegistry<br>ZookeeperTransporter是操作zookeepr的客户端的工厂类，用来创建zookeeper客户端，这里客户端并不是zookeeper源代码的自带的，而是采用第三方工具包，主要来简化对zookeeper的操作，例如用zookeeper做注册中心需要对zookeeper节点添加watcher做反向推送，但是每次回调后节点的watcher都会被删除，这些客户会自动维护了这些watcher，在自动添加到节点上去。<br>接口定义：<br>@SPI ( “zkclient” )<br>public interface ZookeeperTransporter {<br>    @Adaptive ({Constants. CLIENT_KEY , Constants. TRANSPORTER_KEY })<br>    ZookeeperClient connect(URL url);<br>}<br>默认采用zkClient， dubbo源码集成两种zookeeper客户端，除了zkClient还有一个是curator<br><img src="/2017/03/08/zookeeper浅读/4.png" alt="logo"></dubbo:reference></p>
<p>ZookeeperRegistry注册器的实现<br>1.构造器利用客户端创建了对zookeeper的连接，并且添加了自动回复连接的监听器。<br>zkClient = zookeeperTransporter.connect(url);<br>zkClient .addStateListener( new StateListener() {<br>    public void stateChanged( int state) {<br>    if (state == RECONNECTED )<br>        recover();<br>    }<br>});</p>
<p>2.注册url就是利用客户端在服务器端创建url的节点，默认为临时节点，客户端与服务端断开，几点自动删除<br>zkClient .create(toUrlPath(url),url.getParameter(Constants. DYNAMIC_KEY , true));      </p>
<p>3.取消注册的url，就是利用zookeeper客户端删除url节点<br>zkClient .delete(toUrlPath(url));</p>
<ol>
<li><p>订阅url， 功能是服务消费端订阅服务提供方在zookeeper上注册地址，这个功能流程跟DubboRegister不一样， DubboRegister是通过Dubbo注册中心实现SimpleResgiter在注册中心端，对url变换、过滤筛选然后将获取的provierUrl(提供者ulr)利用服务消费者暴露的服务回调在refer。<br>由于这里注册中心采用的是zookeeper，zookeeper不可能具有dubbo的业务逻辑，这里对订阅的逻辑处理都在消费服务端订阅的时候处理。<br> 1) 对传入url的serviceInterface是*代表订阅url目录下所有节点即所有服务，这个注册中心需要订阅所有<br> 2) 如果指定了订阅接口通过toCategoriesPath(url)转换需要订阅的url<br>  如传入url consumer://10.33.37.8/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&amp;category=providers,configurators,routers&amp;dubbo=2.5.4-SNAPSHOT&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=4088&amp;side=consumer&amp;timestamp=1417405597808<br>  转换成urls<br>  /dubbo/com.alibaba.dubbo.demo.DemoService/providers,/dubbo/com.alibaba.dubbo.demo.DemoService/configurators, /dubbo/com.alibaba.dubbo.demo.DemoService/routers<br> 3) 设配传入的回调接口NotifyListener,转换成dubbo对zookeeper操作的ChildListener<br> 4) 以/dubbo/com.alibaba.dubbo.demo.DemoService/providers为例创建节点zkClient.create(path, false);<br>  但是一般情况下如果服务提供者已经提供服务，那么这个目录节点应该已经存在，Dubbo在Client层屏蔽掉了创建异常。<br> 5) 以/dubbo/com.alibaba.dubbo.demo.DemoService/providers为例给节点添加监听器，返回所有子目录<br>  List<string> children = zkClient .addChildListener(path, zkListener);<br>  if (children != null ) {urls.addAll(toUrlsWithEmpty(url, path,hildren));}<br>  toUrlsWtihEmpty用来配置是不是需要订阅的url，是加入集合<br> 6） 主动根据得到服务提供者urls回调NotifyListener,引用服务提供者生成invoker可执行对象</string></p>
</li>
<li><p>取消订阅url， 只是去掉url上的注册的监听器</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面我们来看下开源dubbo推荐的业界成熟的zookeeper做为注册中心， zookeeper是hadoop的一个子项目是分布式系统的可靠协调者，他提供了配置维护，名字服务，分布式同步等服务。对于zookeeper的原理本文档不分析，后面有时间在做专题。&lt;br&gt;zookeeper注册中心&lt;br&gt;Zookeeper对数据存储类似linux的目录结构，下面给出官方文档对dubbo注册数据的存储示例&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="原理研究" scheme="http://yzy755.github.io/categories/%E5%8E%9F%E7%90%86%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="zookeeper" scheme="http://yzy755.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>TCP的几个状态码</title>
    <link href="http://yzy755.github.io/2017/03/08/TCP%E7%9A%84%E5%87%A0%E4%B8%AA%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://yzy755.github.io/2017/03/08/TCP的几个状态码/</id>
    <published>2017-03-08T03:48:05.000Z</published>
    <updated>2017-03-09T09:55:25.371Z</updated>
    
    <content type="html"><![CDATA[<p>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.</p>
<p>其中，对于我们日常的分析有用的就是前面的五个字段。</p>
<p>它们的含义是：</p>
<p>SYN表示建立连接，</p>
<p>FIN表示关闭连接，</p>
<p>ACK表示响应，</p>
<p>PSH表示有 DATA数据传输，</p>
<p>RST表示连接重置。<br><a id="more"></a></p>
<p>其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应，</p>
<p>如果只是单个的一个SYN，它表示的只是建立连接。</p>
<p>TCP的几次握手就是通过这样的ACK表现出来的。</p>
<p>但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。</p>
<p>RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。</p>
<p>一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。</p>
<p>PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。</p>
<p>TCP的连接建立和连接关闭，都是通过请求－响应的模式完成的。</p>
<p>概念补充-TCP三次握手：<br>TCP(Transmission Control Protocol)传输控制协议<br>TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接：</p>
<p>位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)<br>第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；<br>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包；<br>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。<br>完成三次握手，主机A与主机B开始传送数据。<br>TCP采用三次握手建立连接如下图所示。<br><img src="/2017/03/08/TCP的几个状态码/connect.png" alt="logo"><br>用大白话就是这样：<br><img src="/2017/03/08/TCP的几个状态码/connect2.png" alt="logo"></p>
<p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据.</p>
<p>关闭连接：<br>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p> CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<p>（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 </p>
<p>（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 </p>
<p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 </p>
<p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 </p>
<p>TCP采用四次挥手关闭连接如下图所示。<br><img src="/2017/03/08/TCP的几个状态码/close.png" alt="logo"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.&lt;/p&gt;
&lt;p&gt;其中，对于我们日常的分析有用的就是前面的五个字段。&lt;/p&gt;
&lt;p&gt;它们的含义是：&lt;/p&gt;
&lt;p&gt;SYN表示建立连接，&lt;/p&gt;
&lt;p&gt;FIN表示关闭连接，&lt;/p&gt;
&lt;p&gt;ACK表示响应，&lt;/p&gt;
&lt;p&gt;PSH表示有 DATA数据传输，&lt;/p&gt;
&lt;p&gt;RST表示连接重置。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yzy755.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="tcp" scheme="http://yzy755.github.io/tags/tcp/"/>
    
      <category term="三次握手" scheme="http://yzy755.github.io/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    
      <category term="四次挥手" scheme="http://yzy755.github.io/tags/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>jar包在windows下的运行命令</title>
    <link href="http://yzy755.github.io/2017/03/02/jar%E5%8C%85%E5%9C%A8windows%E4%B8%8B%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <id>http://yzy755.github.io/2017/03/02/jar包在windows下运行命令/</id>
    <published>2017-03-02T09:17:53.000Z</published>
    <updated>2017-03-09T09:13:47.771Z</updated>
    
    <content type="html"><![CDATA[<p>1、打jar包 jar -cvf xx.jar 文件夹名称</p>
<p>说明一下：<em>.</em>表示把当前目录下面以及子目录的所有class都打到这个xx.jar里。</p>
<p>-cvf的含义，可以自己去用jar命令去查看</p>
<p>如果要单独对某个或某些class文件进行打包，可以这样：</p>
<p>jar -cvf xx.jar Foo.class Bar.class </p>
<a id="more"></a>
<p>2.运行jar</p>
<p>java -jar xx.jar</p>
<p>要运行一个jar，则此jar内部的META-INF\MANIFEST.MF文件里必须指明要执行的main方法类</p>
<p>具体格式如：</p>
<p>Manifest-Version: 1.0<br>Created-By: 1.6.0_03 (Sun Microsystems Inc.)<br>Main-class: Test<br>如果此处的Test.class在com.xx包下面，则需要指明。</p>
<p>如果在运行时报了invalid or corrupt jarfile错误，则需要检查Main-class: Test 之间是不是缺少了空格。</p>
<p>3.指定运行jar里面的class</p>
<p>java -cp xx.jar com.xx.Test</p>
<p>4.编译某个java文件，但是依赖某个jar</p>
<p>javac -cp xx.jar Test.java</p>
<p> (Test.java里面import了xx.jar里面的某个class)</p>
<p>5.运行某个java文件，但是依赖某个jar</p>
<p>java -cp .;xx.jar Test</p>
<p>注意：引用xx.jar的时候，不要漏掉.;（这个表示当前目录）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、打jar包 jar -cvf xx.jar 文件夹名称&lt;/p&gt;
&lt;p&gt;说明一下：&lt;em&gt;.&lt;/em&gt;表示把当前目录下面以及子目录的所有class都打到这个xx.jar里。&lt;/p&gt;
&lt;p&gt;-cvf的含义，可以自己去用jar命令去查看&lt;/p&gt;
&lt;p&gt;如果要单独对某个或某些class文件进行打包，可以这样：&lt;/p&gt;
&lt;p&gt;jar -cvf xx.jar Foo.class Bar.class &lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yzy755.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yzy755.github.io/tags/java/"/>
    
      <category term="jar包" scheme="http://yzy755.github.io/tags/jar%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>solr部署</title>
    <link href="http://yzy755.github.io/2017/03/02/solr%E9%83%A8%E7%BD%B2/"/>
    <id>http://yzy755.github.io/2017/03/02/solr部署/</id>
    <published>2017-03-02T09:17:53.000Z</published>
    <updated>2017-03-09T09:12:45.411Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.tuicool.com/articles/mueARf" target="_blank" rel="external">http://www.tuicool.com/articles/mueARf</a> 参考</p>
<p>请下载tgz包而不是zip包，特此提醒！ 解压solr-5.1.0.zip到任意盘符，如图：</p>
<p>复制solr.war到tomcat的webapps目录下，如图操作：</p>
<p>启动tomcat,如图：<br><a id="more"></a><br>然后修改webapps\solr\WEB-INF下的web.xml配置文件，如图：</p>
<p>配置solr_home目录路径，如图：</p>
<p>然后我们需要去C盘创建一个solr_home文件夹，这就是我们SOLR_HOME根目录啦，如图：</p>
<p>然后我们需要把E:\solr-5.1.0\server\solr目录下的所有文件及文件夹全部复制到我们刚刚创建的solr_home目录下，如图：</p>
<p>然后我们需要把E:\solr-5.1.0\server\lib\ext目录下的所有jar包 copy到E:\apache-tomcat-7.0.55\webapps\solr\WEB-INF\lib目录下(<br>E:\apache-tomcat-7.0.55是我的tomcat安装根目录，请对照你们自己的tomcat安装目录进行调整，你懂的<br>)，如图：</p>
<p>然后复制 E:\solr-5.1.0\server\resources目录下的log4j.properties配置文件到E:\apache-tomcat-7.0.55\webapps\solr\WEB-INF目录下，如图操作：</p>
<p>然后重启我们的tomcat,如图：</p>
<p>打开你的浏览器，地址栏输入 <a href="http://localhost:8080/solr" target="_blank" rel="external">http://localhost:8080/solr</a> ， 访问我们的Solr Web后台。如果你能看到这个界面，即表明Solr5部署成功了，如图：</p>
<p>然后你就可以通过Solr Web UI添加Core啦，不过添加Core之前，你需要在solr_home目录下创建core文件夹，如图：<br>core目录下需要创建conf和data文件夹，你懂的， 《跟益达学Solr5之使用Jetty部署Solr》<br>这篇博客也提到过，如图：</p>
<p>剩下的一些配置copy具体你们就参照那篇去操作把，这里就不重复说明了。<br>到此，Solr5如何部署到Tomcat就讲解完毕了！</p>
<p>IK 分词器安装<br>1.将之前解压的solr-4.3.1 下的contrib和dist 文件夹复制到F:\winsolr\solr_home\solr\collection1下<br>2.将下载的IKAnalyzer的发行包解压，解压后将IKAnalyzer2012FF_u1.jar（分词器jar包）复制到F:\winsolr\solr_home\solr\collection1\contrib\analysis-extras\lib下<br>3.在F:\winsolr\apache-tomcat-7.0.37\webapps\solr\WEB-INF下新建classes文件夹<br>4.将IKAnalyzer解压出来的IKAnalyzer.cfg.xml（分词器配置文件）和 Stopword.dic（分词器停词字典,可自定义添加内容）复制到<br>  F:\winsolr\apache-tomcat-7.0.37\webapps\solr\WEB-INF\classes中<br>5.在F:\winsolr\solr_home\solr\collection1\conf下的schema.xml文件中fieldType name=”text_general”这个地方的上方添加以下内容 </p>
<p>将pinyinfj.jar、lucene-analyzers-smartcn-4.7.0.jar、IKAnalyzer2012FF_u1.jar、pinyinAnalyzer.jar、shentong_tsearch_lib.jar放到solr部署目录的web-inf的lib目录下</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.tuicool.com/articles/mueARf&quot;&gt;http://www.tuicool.com/articles/mueARf&lt;/a&gt; 参考&lt;/p&gt;
&lt;p&gt;请下载tgz包而不是zip包，特此提醒！ 解压solr-5.1.0.zip到任意盘符，如图：&lt;/p&gt;
&lt;p&gt;复制solr.war到tomcat的webapps目录下，如图操作：&lt;/p&gt;
&lt;p&gt;启动tomcat,如图：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yzy755.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="solr" scheme="http://yzy755.github.io/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序对接支付</title>
    <link href="http://yzy755.github.io/2017/03/02/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AF%B9%E6%8E%A5%E6%94%AF%E4%BB%98/"/>
    <id>http://yzy755.github.io/2017/03/02/微信小程序对接支付/</id>
    <published>2017-03-02T09:17:53.000Z</published>
    <updated>2017-03-09T09:12:11.559Z</updated>
    
    <content type="html"><![CDATA[<p>所有支付方式都需要通过 「统一下单」的 API 来获取一个支付凭证。<br>但在小程序内测期间，还没有「统一下单」的概念。HTML 5 应用发起支付需要直接通过前端构造参数来发起（不经过后端验证），很容易造成支付凭证泄露等安全问题。<br>为此，微信支付将其流程进行了优化：在所有支付场景中插入「统一下单」的特性。推荐开发者在后端完成支付参数的构建等行为。<br>该优化带来以下好处:</p>
<pre><code>* 尽可能让开发者不犯低级错误，造成财务损失。
* 简化构造支付参数的复杂度，所有支付方式可共享一个支付后端接口。
</code></pre><a id="more"></a>
<p>通过「统一下单」获取到相对应 prepay_id 或者 code_url 等参数，即可通过各种支付模式的 SDK 来进行微信支付的发起。<br>需要注意的是，必须对通知参数进行签名验证，以确保安全。<br>进行签名验证时，除去签名字段（一般参数名为: sign）不需要参与签名外，其余所有接收到的参数均需要参与签名。<br>比如拼接的请求支付宝的参数为total_fee,body,appid，那么签名就必须用这三个参数<br>得到prepay_id后还需在发起wx.requestPayment前对 wx.requestPayment请求所需的参数进行签名<br>所需的参数为’timeStamp’: res.data.timeStamp,<br>            ‘nonceStr’: nonce_str,<br>            ‘package’: ‘prepay_id=’+prepay_id,<br>            ‘signType’: ‘MD5’,<br>            ‘paySign’: res.data.sign,<br>但是后台生成该签名还需appId（I大写！！）随后用返回的参数和生成的timeStamp进行请求（ appId、timeStamp、nonceStr、package、signType）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有支付方式都需要通过 「统一下单」的 API 来获取一个支付凭证。&lt;br&gt;但在小程序内测期间，还没有「统一下单」的概念。HTML 5 应用发起支付需要直接通过前端构造参数来发起（不经过后端验证），很容易造成支付凭证泄露等安全问题。&lt;br&gt;为此，微信支付将其流程进行了优化：在所有支付场景中插入「统一下单」的特性。推荐开发者在后端完成支付参数的构建等行为。&lt;br&gt;该优化带来以下好处:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 尽可能让开发者不犯低级错误，造成财务损失。
* 简化构造支付参数的复杂度，所有支付方式可共享一个支付后端接口。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yzy755.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="微信小程序" scheme="http://yzy755.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
